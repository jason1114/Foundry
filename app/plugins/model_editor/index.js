// Generated by CoffeeScript 1.8.0
(function() {
  var common_fields, define_controller, supported_field, supported_field_setting;

  supported_field = window.app_config.supported_field;

  supported_field_setting = window.app_config.supported_field_setting;

  common_fields = window.app_config.common_fields;

  define('model_editor', function() {
    var user_plugin;
    return user_plugin = {
      name: 'model_editor',
      anchor: '#/model_editor',
      title: 'Configuration',
      type: 'plugin',
      icon: 'icon-pencil',
      init: function() {
        var attrs, field, fields_num, self, _results;
        self = this;
        console.log('init');
        fields_num = Object.keys(supported_field).length;
        _results = [];
        for (field in supported_field) {
          attrs = supported_field[field];
          _results.push(foundry.model(field, attrs.concat(common_fields), function() {
            if (fields_num-- === 1) {
              foundry.initialized(self.name);
              return define_controller();
            }
          }));
        }
        return _results;
      }
    };
  });

  define_controller = function() {
    return angular.module('foundry').controller('ModelEditorController', [
      '$scope', '$foundry', function($scope, $foundry) {
        var field_name, save_recent_tabs, supported_field_models, _i, _len, _ref;
        window.scope = $scope;
        $scope.encodeURI = window.encodeURI;
        $scope.$safeApply = function(fn) {
          var phase;
          phase = this.$root.$$phase;
          if (phase === '$apply' || phase === '$digest') {
            if (fn && (typeof fn === 'function')) {
              return fn();
            }
          } else {
            return this.$apply(fn);
          }
        };
        $scope.choose_a_model = "--Choose a model--";
        $scope.tab_to_add = $scope.choose_a_model;
        if (window.localStorage && window.localStorage.recent_tabs_model) {
          $scope.tabs = JSON.parse(window.localStorage.recent_tabs_model);
        } else {
          $scope.tabs = [];
        }
        save_recent_tabs = function() {
          if (window.localStorage && $scope.tabs) {
            return window.localStorage.recent_tabs_model = JSON.stringify($scope.tabs);
          }
        };
        $scope.add_tab = function() {
          var tab_to_add;
          tab_to_add = $scope.tab_to_add;
          $scope.tab_to_add = $scope.choose_a_model;
          if (!tab_to_add) {
            return;
          }
          if ($scope.tabs.indexOf(tab_to_add) !== -1) {
            $scope.selected_model = tab_to_add;
            return;
          }
          if ($scope.tabs.length >= 10) {
            sweetAlert("Oops...", "You can only open 10 tabs at most.", "error");
            return;
          }
          $scope.tabs.push(tab_to_add);
          $scope.selected_model = tab_to_add;
          $scope.$safeApply();
          return save_recent_tabs();
        };
        $scope.del_tab = function($index) {
          if ($scope.tabs[$index] === $scope.selected_model) {
            if ($scope.tabs[$index - 1]) {
              $scope.selected_model = $scope.tabs[$index - 1];
            } else if ($scope.tabs[$index + 1]) {
              $scope.selected_model = $scope.tabs[$index + 1];
            } else {
              $scope.selected_model = null;
            }
          }
          $scope.tabs.splice($index, 1);
          $scope.$safeApply();
          return save_recent_tabs();
        };
        $scope.fields_in_new_model = [];
        $scope.supported_field_setting = supported_field_setting;
        supported_field_models = {};
        _ref = Object.keys(supported_field);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field_name = _ref[_i];
          supported_field_models[field_name] = foundry.load_model(field_name);
        }
        $scope.push_field_to_model = function(type) {
          var field, field_model, field_to_create, setting, target, to_push, _j, _len1;
          target = $scope.selected_model ? $scope.generated_models[$scope.selected_model] : $scope.fields_in_new_model;
          for (_j = 0, _len1 = target.length; _j < _len1; _j++) {
            field = target[_j];
            if (field.name === $scope.field_name_to_add) {
              sweetAlert("Oops...", "Field name " + field.name + " already exists.", "error");
              return;
            }
          }
          to_push = {
            name: $scope.field_name_to_add,
            type: type,
            setting: null
          };
          setting = {};
          supported_field[type].map(function(attr) {
            var s;
            s = "" + type + "_" + attr;
            return setting[attr] = $scope[s];
          });
          to_push.setting = setting;
          if ($scope.selected_model) {
            field_to_create = angular.copy(setting);
            field_to_create.model_belonged_to = $scope.selected_model;
            field_to_create.field_name = to_push.name;
            field_model = supported_field_models[to_push.type];
            field_model.create(field_to_create);
            return $scope.load();
          } else {
            return $scope.fields_in_new_model.push(to_push);
          }
        };
        $scope.delete_field_from_new_model = function(index) {
          return $scope.fields_in_new_model.splice(index, 1);
        };
        $scope.model_rename = {};
        $scope.in_rename = {};
        $scope.enter_rename = function(field_info) {
          $scope.in_rename[field_info.setting.id] = true;
          return $scope.model_rename[field_info.setting.id] = field_info.setting.field_name;
        };
        $scope.cancel_rename = function(field_info) {
          $scope.in_rename[field_info.setting.id] = false;
          return delete $scope.model_rename[field_info.setting.id];
        };
        $scope.rename_field = function(field_info) {
          var new_field_name, new_fields, old_fields;
          old_fields = $scope.generated_models[field_info.setting.model_belonged_to].map(function(field_info) {
            return field_info.name;
          });
          new_field_name = $scope.model_rename[field_info.setting.id];
          if (!new_field_name) {
            sweetAlert("Oops...", "New field name can't be empty.", "error");
            return;
          }
          if (old_fields.indexOf(new_field_name) !== -1) {
            sweetAlert("Oops...", "Fild name " + new_field_name + " already exists.", "error");
            return;
          }
          new_fields = old_fields.concat(new_field_name);
          return foundry.model(field_info.setting.model_belonged_to, new_fields, function(new_user_model) {
            var record, _j, _len1, _ref1;
            _ref1 = new_user_model.all();
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              record = _ref1[_j];
              record[new_field_name] = record[field_info.name];
              record.save();
            }
            field_info.setting.field_name = new_field_name;
            field_info.setting.save();
            $scope.load();
            $scope.$safeApply();
            return $scope.cancel_rename(field_info);
          });
        };
        $scope.add_model = function() {
          var model, name, _ref1;
          _ref1 = foundry._models;
          for (name in _ref1) {
            model = _ref1[name];
            if (name === $scope.new_model_name) {
              sweetAlert("Oops...", "Model " + $scope.new_model_name + " already exists.", "error");
              return;
            }
          }
          return foundry.model($scope.new_model_name, $scope.fields_in_new_model.map(function(field) {
            return field.name;
          }), function(user_model) {
            var field, field_model, _j, _len1, _ref2;
            _ref2 = $scope.fields_in_new_model;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              field = _ref2[_j];
              field_model = supported_field_models[field.type];
              field.setting.model_belonged_to = $scope.new_model_name;
              field.setting.field_name = field.name;
              field_model.create(field.setting);
            }
            $scope.load();
            $scope.tab_to_add = $scope.new_model_name;
            $scope.add_tab();
            $scope.selected_model = $scope.new_model_name;
            return $scope.$safeApply();
          });
        };
        $scope.model_edit = {};
        $scope.enter_edit = function(field) {
          return $scope.model_edit[field.id] = angular.copy(field);
        };
        $scope.cancel_edit = function(field) {
          return delete $scope.model_edit[field.id];
        };
        $scope.edit_model = function(field) {
          field.save();
          $scope.$safeApply();
          return $scope.cancel_edit(field);
        };
        $scope.del_field = function(field) {
          return swal({
            title: "Are you sure?",
            text: "The field will be deleted, and the data in this field will gone as well",
            type: "warning",
            showCancelButton: true,
            confirmButtonColor: "#DD6B55",
            confirmButtonText: "Yes, delete it!",
            cancelButtonText: "No, cancel plx!",
            closeOnConfirm: false,
            closeOnCancel: false
          }, function(isConfirm) {
            if (isConfirm) {
              if ($scope.generated_models[field.setting.model_belonged_to].length <= 1) {
                swal("Cancelled", "Your can't delete the only field of a model :)", "error");
                return;
              }
              field.setting.destroy();
              $scope.load();
              $scope.$safeApply();
              return swal("Deleted!", "Your model and data has been deleted.", "success");
            } else {
              return swal("Cancelled", "Your model and data are safe :)", "error");
            }
          });
        };
        $scope.del_model = function(name) {
          return swal({
            title: "Are you sure?",
            text: "The model will be deleted as well as the data stored in it!",
            type: "warning",
            showCancelButton: true,
            confirmButtonColor: "#DD6B55",
            confirmButtonText: "Yes, delete it!",
            cancelButtonText: "No, cancel plx!",
            closeOnConfirm: false,
            closeOnCancel: false
          }, function(isConfirm) {
            var field, model_to_del, new_model_name_list, _j, _len1, _ref1;
            if (isConfirm) {
              model_to_del = $scope.user_models[name];
              if (model_to_del) {
                model_to_del.all().map(function(data) {
                  return data.destroy();
                });
              }
              _ref1 = $scope.generated_models[name];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                field = _ref1[_j];
                field.setting.destroy();
              }
              $scope.load();
              new_model_name_list = Object.keys($scope.generated_models);
              $scope.selected_model = new_model_name_list[0];
              $scope.$safeApply();
              return swal("Deleted!", "Your model and data has been deleted.", "success");
            } else {
              return swal("Cancelled", "Your model and data are safe :)", "error");
            }
          });
        };
        $scope.change_selected = function(name) {
          return $scope.selected_model = name;
        };
        $scope.load = function() {
          var attrs, field, field_info, model, model_info_list, name, _j, _len1, _ref1, _ref2, _results;
          $scope.generated_models = {};
          for (name in supported_field_models) {
            model = supported_field_models[name];
            _ref1 = model.all();
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              field = _ref1[_j];
              if (!$scope.generated_models[field.model_belonged_to]) {
                $scope.generated_models[field.model_belonged_to] = [];
              }
              field_info = {
                name: field.field_name,
                type: name,
                setting: field
              };
              $scope.generated_models[field.model_belonged_to].push(field_info);
            }
          }
          $scope.user_models = {};
          _ref2 = $scope.generated_models;
          _results = [];
          for (name in _ref2) {
            model_info_list = _ref2[name];
            attrs = model_info_list.map(function(model_info) {
              return model_info.name;
            });
            _results.push(foundry.model(name, attrs, function(loaded_model) {
              return $scope.user_models[name] = loaded_model;
            }));
          }
          return _results;
        };
        return $scope.load();
      }
    ]);
  };

}).call(this);
