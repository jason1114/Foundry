// Generated by CoffeeScript 1.8.0
(function() {
  var common_fields, define_controller, supported_field, supported_field_setting;

  supported_field = {
    '_field_switch': ["on_value", "off_value", "default_value"],
    '_field_text_input': ["default_value", "required"],
    '_field_text_area': ["default_value", "required"],
    '_field_rate': ["default_value", "max_rate", "required"],
    '_field_number_input': ["default_value", "max_value", "min_value", "required"],
    '_field_image': ["required"]
  };

  supported_field_setting = {
    '_field_switch': ["Switch"],
    '_field_text_input': ["Text Input"],
    '_field_text_area': ["Text Area"],
    '_field_rate': ["Rate"],
    '_field_number_input': ["Nimber Input"],
    '_field_image': ["Image"]
  };

  common_fields = ["model_belonged_to", "field_name"];

  define('model_editor', function() {
    var user_plugin;
    return user_plugin = {
      name: 'model_editor',
      anchor: '#/model_editor',
      title: 'Model Editor',
      type: 'plugin',
      icon: 'icon-pencil',
      init: function() {
        var attrs, field, fields_num, self, _results;
        self = this;
        console.log('init');
        fields_num = Object.keys(supported_field).length;
        _results = [];
        for (field in supported_field) {
          attrs = supported_field[field];
          _results.push(foundry.model(field, attrs.concat(common_fields), function() {
            if (fields_num-- === 1) {
              foundry.initialized(self.name);
              return define_controller();
            }
          }));
        }
        return _results;
      }
    };
  });

  define_controller = function() {
    return angular.module('foundry').controller('ModelEditorController', [
      '$scope', '$foundry', function($scope, $foundry) {
        var field_name, generated_prefix, supported_field_models, _i, _len, _ref;
        window.scope = $scope;
        generated_prefix = "_model_";
        $scope.generated_models = {};
        $scope.fields_in_new_model = [];
        $scope.supported_field_setting = supported_field_setting;
        supported_field_models = {};
        _ref = Object.keys(supported_field);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field_name = _ref[_i];
          supported_field_models[field_name] = foundry.load_model(field_name);
        }
        $scope.push_field_to_new_model = function(type) {
          var field, setting, to_push, _j, _len1, _ref1;
          _ref1 = $scope.fields_in_new_model;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            field = _ref1[_j];
            if (field.name === $scope.field_name_to_add) {
              sweetAlert("Oops...", "Field name " + field.name + " already exists.", "error");
              return;
            }
          }
          to_push = {
            name: $scope.field_name_to_add,
            type: type,
            setting: null
          };
          setting = {};
          supported_field[type].map(function(attr) {
            var s;
            s = "" + type + "_" + attr;
            return setting[attr] = $scope[s];
          });
          to_push.setting = setting;
          return $scope.fields_in_new_model.push(to_push);
        };
        $scope.delete_field_from_new_model = function(index) {
          return $scope.fields_in_new_model.splice(index, 1);
        };
        $scope.add_model = function() {
          var inner_model_name, model, name, _ref1;
          inner_model_name = generated_prefix + $scope.new_model_name;
          _ref1 = foundry._models;
          for (name in _ref1) {
            model = _ref1[name];
            if (name === inner_model_name) {
              sweetAlert("Oops...", "Model " + $scope.new_model_name + " already exists.", "error");
              return;
            }
          }
          return foundry.model(inner_model_name, $scope.fields_in_new_model.map(function(field) {
            return field.name;
          }), function() {
            var field, field_model, _j, _len1, _ref2;
            _ref2 = $scope.fields_in_new_model;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              field = _ref2[_j];
              field_model = supported_field_models[field.type];
              field.setting.model_belonged_to = $scope.new_model_name;
              field.setting.field_name = field.name;
              field_model.create(field.setting);
            }
            $scope.load();
            return $scope.$apply();
          });
        };
        $scope.load = function() {
          var model, name, _ref1, _results;
          _ref1 = foundry._models;
          _results = [];
          for (name in _ref1) {
            model = _ref1[name];
            if (name.indexOf(generated_prefix) !== -1) {
              _results.push($scope.generated_models[name.substr(generated_prefix.length)] = model);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        return $scope.load();
      }
    ]);
  };

}).call(this);
